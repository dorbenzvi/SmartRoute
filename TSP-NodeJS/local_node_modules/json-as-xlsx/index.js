/** @format */

var __assign =
  (this && this.__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    return __assign.apply(this, arguments);
  };
var _a = require("xlsx"),
  utils = _a.utils,
  write = _a.write,
  writeFile = _a.writeFile;
module.exports = function (
  columns,
  stopsColumns,
  content,
  stopInfo,
  settings,
  download
) {
  if (settings === void 0) {
    settings = {};
  }
  if (download === void 0) {
    download = true;
  }
  var extraLength = settings.extraLength || 1;
  var writeOptions = settings.writeOptions || {};
  var excelColumns = 0;
  var excelContent = [];
  var excelContent2 = [];
  var excelIndexes = [];
  var excelIndexes2 = [];
  content.forEach(function (el1) {
    var obj = {};
    columns.forEach(function (el2, in2) {
      var val =
        typeof el2.value === "function" ? el2.value(el1) : el1[el2.value];
      obj[el2.label] = val;
      excelColumns = in2 + 1;
    });
    excelContent.push(obj);
  });
  var newSheet = utils.json_to_sheet(excelContent);
  {
    var rangeOfColumns = utils.decode_range(newSheet["!ref"]);
    for (var C = rangeOfColumns.s.c; C <= rangeOfColumns.e.c; C++) {
      var address = utils.encode_col(C) + "1";
      excelIndexes.push(address);
    }
  }
  newSheet["!cols"] = [];
  var whileLoop = 0;
  while (whileLoop < excelColumns) {
    var xx = excelIndexes[whileLoop];
    var size = { width: newSheet[xx].v.length + extraLength };
    for (var keyIndex in newSheet) {
      if (
        newSheet.hasOwnProperty(keyIndex) &&
        xx.charAt(0) === keyIndex.charAt(0) &&
        keyIndex.length === xx.length
      ) {
        var consideredElement = newSheet[keyIndex].v;
        if (typeof consideredElement === "number")
          consideredElement = "" + consideredElement;
        if (consideredElement && consideredElement.length >= size.width)
          size.width = consideredElement.length + extraLength;
      }
    }
    newSheet["!cols"].push(size);
    whileLoop++;
  }

  //---------------------------------------
  stopInfo.forEach(function (el1) {
    var obj = {};
    stopsColumns.forEach(function (el2, in2) {
      var val =
        typeof el2.value === "function" ? el2.value(el1) : el1[el2.value];
      obj[el2.label] = val;
      excelColumns = in2 + 1;
    });
    excelContent2.push(obj);
  });
  var newSheet2 = utils.json_to_sheet(excelContent2);
  {
    var rangeOfColumns = utils.decode_range(newSheet["!ref"]);
    for (var C = rangeOfColumns.s.c; C <= rangeOfColumns.e.c; C++) {
      var address = utils.encode_col(C) + "1";
      excelIndexes.push(address);
    }
  }
  newSheet2["!cols"] = [];
  var whileLoop = 0;
  while (whileLoop < stopsColumns) {
    var xx = excelIndexes2[whileLoop];
    var size = { width: newSheet[xx].v.length + extraLength };
    for (var keyIndex in newSheet2) {
      if (
        newSheet2.hasOwnProperty(keyIndex) &&
        xx.charAt(0) === keyIndex.charAt(0) &&
        keyIndex.length === xx.length
      ) {
        var consideredElement = newSheet2[keyIndex].v;
        if (typeof consideredElement === "number")
          consideredElement = "" + consideredElement;
        if (consideredElement && consideredElement.length >= size.width)
          size.width = consideredElement.length + extraLength;
      }
    }
    newSheet2["!cols"].push(size);
    whileLoop++;
  }
  var wb = utils.book_new();
  utils.book_append_sheet(wb, newSheet, "" + (settings.sheetName || "Sheet 1"));
  utils.book_append_sheet(wb, newSheet2, "" + "Stops Info");
  return download
    ? writeFile(
        wb,
        (settings.fileName || "Spreadsheet") + ".xlsx",
        writeOptions
      )
    : write(wb, __assign({ type: "buffer", bookType: "xlsx" }, writeOptions));
};